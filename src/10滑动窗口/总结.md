## 滑动窗口 [题单](https://leetcode.cn/circle/discuss/0viNMK/)
* 必须有单调性（恒定非正或非负）才可以用滑动窗口,是一种特殊的同向双指针
* 当计算和时，如果窗口缩小后left和right指针的值会相等（非完全递增），需加上限制条件left<=right
### 1>定长滑动窗口：入-更新-出<br/>
入：下标为 i 的元素进入窗口，更新相关统计量。如果 i<k−1 则重复第一步。<br/>
更新：更新答案。一般是更新最大值/最小值。 <br/>
出：下标为 i−k+1 的元素离开窗口，更新相关统计量。<br/>
```
1.如果需要计算和，数组中有负数或逻辑复杂，可以先计算前k个总和
let sum= nums.slice(0,k).reduce((a,b)=>a+b);
let res = sum;
for(let i=k;i<nums.length;i++){
    ...
}
2.通用公式
for(let i=0;i<arr.length;i++){
    // 入
    sum+=arr[i];
    if(i+1<k) continue;
    // 记录结果  判断界定条件
    if(sum>=target){
        res++;
    }
    // 出
    sum -=arr[i-k+1];
}
```
```
技巧：
1、1461 获取长度为k的子字符串 s.slice(i,i+k) 或 滑窗:入str +=s[i] 出 str=str.slice(1) 
2、1423 先获取前k个的和，从1循环到k，再加右侧n-i,减左侧（右边）k-i。
3、1652 方法一 复制两个不怕越界 计算res[0]的和，再循环获取所有的数  方法二 用余数
4、经典 1297
```
> 1.判断两个字母的字符个数都一样--字母异位词分组

    1>排序 [...str].sort().toSting()  排序后字符串相等（a,b,c），可以作为哈希表的键
    2>计数 count[c.charCodeAt()-'a'.charCodeAt()]++  count可以作为map={}的键
> 2.判断两个字母的个数是否不一样

    先计算出字母A的所有个数count 计算B时循环字符x count[x]-- 如果count[x]<0则表示两个字母不是异位词
> 3.重复两个数组，取首尾连续子数组防止越界 数组值用nums[i%n] (例题：1652、2875)
```
// 循环两个相同数组，求连续子数组的和，可以避免首尾问题
for(let i=0;i<2*n;i++){
    // 用余数获取当前下标
    count +=nums[i%n];
    while(count>target%sum){
        count -=nums[left++%n];
    }
}
```
### 2>不定长滑动窗口
#### 主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。
> **1、求最长/最大   一般题目都有「至多」的要求**
```
let map = new Map();
let left = 0;
let res = 0;
for(let i=0;i<s.length;i++){
    map.set(s[i],(map.get(s[i])||0)+1);
    // 判断条件，缩小窗口
    while(map.get(s[i])>2){
        map.set(s[left],(map.get(s[left])||0)-1);
        left++;
    }
    // 记录结果
    res = Math.max(res,i-left+1);
}
return res;
```
```
技巧：
1、判断重复字符用set 先判断set.has(nums[i]) 再加set.add(nums[i])
2、只有0、1的数组，cnt0记录0的个数，可以用1-nums[i]  cnt0 += 1-nums[i]
3、2779 nums[i]可替换为[nums[i] - k, nums[i] + k] 画图用区间表示，排序后求x+k和y-k有交集即y-x<=2k时最大的x和y的长度
4、2024 只有T、F的数组，最多替换k次得到最长连续数组 判断条件为T、F的个数都超过k时缩小窗口
5、1838 排序数组 right增加，left到right下标的差值累加，sum +=nums([right]-nums[right-1])*(right-left);
6、2831 分组思路 将相同元素下标作为数组，分组。循环每个分组进行滑窗，删除的个数为v[right]-v[left]-(right-left)
```
#### 正难则反（将取首尾的数据转化为取中间连续的数）
    1658 逆向思维 求和为x的最小个数（可首尾拿取），转化为求和为s-x的最长子数组的长度（必连续）
    2516 每种字符至少取k个，转化为剩下字母至多有sum-k个 计算s的最长子串长度，该子串满足a,b,c的个数分别至多为 x−k,y−k,z−k
> **2、求最短/最小   一般题目都有「至少」的要求**
```
let res = Infinity;
let sum = 0;
let left = 0;
for(let i=0;i<nums.length;i++){
    sum +=nums[i];
    // 和大于等于target时，结果满足，记录结果，由于是正整数，右移肯定满足，因此需缩小窗口找到更小的
    while(sum>=target){
        res = Math.min(res,i-left+1);
        sum -=nums[left];
        left++;
    }
}
// 如果没有满足条件的，则返回0
return res==Infinity?0:res;
```
```
技巧：
2904 while条件：个数超过k或者左侧字段为0，都要缩小窗口 while后记录结果
1234 在删除后所有字符的个数都小于target，此时可以替换为平衡字符串，左指针右滑获取最小结果。
```
> **3、求子数组个数**
>>1.越长越合法 一般要写 ans += left
>>>滑动窗口的内层循环结束时，右端点固定在right,左端点在0,1,2,…,left−1的所有子数组（子串）都是合法的，这一共有left个。
```
let ans = 0, left = 0;
const cnt = [0, 0, 0];
for (let right = 0; right < s.length; right++) {
    cnt[s.charCodeAt(right) - 'a'.charCodeAt(0)]++;
    while (cnt[0] > 0 && cnt[1] > 0 && cnt[2] > 0) {
        cnt[s.charCodeAt(left) - 'a'.charCodeAt(0)]--;
        left++;
    }
    ans += left;
}
return ans;
```
>>2.越短越合法 一般要写 ans += right - left + 1
>>>滑动窗口的内层循环结束时，右端点固定在right,左端点在left,left+1,…,right的所有子数组（子串）都是合法的，这一共有right−left+1 个。<br/>

>>3.恰好型滑动窗口
>>>「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。或两个至多，越短越合法
```
例1248
var numberOfSubarrays = function(nums, k) {
    // 大于等于k个奇数 减去 大于等于k+1个奇数 等于恰好为k个奇数的个数
    return getRes(nums,k)-getRes(nums,k+1);
};

// 获取大于等于k个奇数的个数
function getRes(nums,k){
    let res = 0;
    let left = 0;
    // 记录奇数的个数
    let sum = 0;
    for(let i=0;i<nums.length;i++){
        sum +=nums[i]%2;
        while(sum>=k){
            sum -=nums[left++]%2;
        }
        // i=3 left=1 1121 i=4 left=2 11211 1211
        res +=left;
    }
    return res;
}
```
>>> 三指针滑动窗口：也可以把两个滑动窗口合并起来，维护同一个右端点right和两个左端点left1和left2
```
例930 nums = [1,0,1,0,1], goal = 2
// 三指针滑动窗口  用至少和为goal的子数组个数减去至少和为goal+1的子数组个数 两个越长越合法
let l1 = l2 = sum1 = sum2 = 0;
let res = 0;
for(let r=0;r<nums.length;r++){
    sum1 +=nums[r];
    sum2 +=nums[r];
    // 计算至少和为goal的子数组个数
    while(l1<=r && sum1>=goal){
        sum1 -=nums[l1++];
    }
    // 计算至少和为goal的子数组个数
    while(l2<=r && sum2>=goal+1){
        sum2 -=nums[l2++];
    }
    // r=2 l1=1 sum1=1 101 +1  
    // r=3 l1=1 l2=0 1010 +1
    // r=4 l1=3 sum1=1 10101 0101 101 +3 l2=1 sum2=2 10101 +1 实际满足0101 101 l1-l2=2
    res +=l1-l2;
}
return res;
```

