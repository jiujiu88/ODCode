/*
题目描述
有一个荒岛，只有左右两个港口，只有一座桥连接这两个港口，现在有一群人需要从两个港口逃生，有的人往右逃生，
有的往左逃生，如果两个人相遇，则PK，体力值大的能够打赢体力值小的，体力值相同则同归于尽，赢的人才能继续往前逃生，并较少相应地体力。

输入描述
一行非0整数，用空格隔开，正数代表向右逃生，负数代表向左逃生。

输出描述
最终能够逃生的人数。

示例1
输入：
5 10 8 -8 -5
输出：
2
说明：
第3个人和第4个人同归于尽，第2个人杀死第5个人并剩余5战斗力，第1个人没有遇到敌人。

输入
-1 -2 -3 5 3
输出
5
说明：前三个人往左跑，直接逃脱，剩下的都往右跑

输入
10 -1 -2 -3 3
输出
2
说明：第一个人杀死第2、3、4个人，还剩余4战斗力，第5个人往右边跑

解题思路
1、本题为什么采用栈？
栈是一个后进先出（LIFO, Last In First Out）的数据结构。这里使用栈来存储正数（向右逃生的人）。
当遇到负数（向左逃生的人）时，会检查栈顶的元素（也就是最后一个进入栈的向右逃生的人），并进行体力值的比较和PK处理。
栈非常适合这种场景，因为我们只需要考虑最新加入的向右逃生的人（栈顶元素），逐步处理每次遇到的负数（向左逃生的人）。
2、本题为什么采用贪心算法？
贪心算法是一种在每一步选择中都采取当前最优解的策略。在本题中，两个逃生的人相遇时，体力值大的赢，这就是贪心的核心思想。
每次 PK 的时候，只需要比较栈顶的正数和当前的负数，并根据体力值大小直接消耗体力或决定逃生人数。
通过贪心策略，每次都处理当前局部最优的情况，逐步得到最终能逃生的人数。

3、解题思路
题意是这样的：
体力值大的能够打赢体力值小的，体力值相同则同归于尽，赢的人才能继续往前逃生，并较少相应地体力。
正数代表向右逃生，负数代表向左逃生。
首先将输入的一行非零整数转换为一个整数数组，正数代表向右逃生，负数代表向左逃生。
遍历数组中的每一个元素：
如果遇到正数（向右逃生），将其压入栈中。
如果遇到负数（向左逃生），则通过栈顶元素（即向右逃生的人）的体力值与当前负数进行比较，模拟两者相遇后发生的 PK。
PK 逻辑
如果栈顶的正数体力值大于负数：正数赢，栈顶的正数体力值减少，负数被完全消耗掉。
如果栈顶的正数体力值小于或等于负数：正数被弹出（栈顶元素被移除），负数的体力值减少或完全消耗。
如果栈为空（所有向右逃生的人都被消耗），负数将无法遇到任何人，可以直接存活。
计算最终结果
最后剩下的栈中元素表示仍然存活的向右逃生的人数。
遍历过程中累积的负数（向左逃生）如果没有被完全消耗，则表示能够逃生的向左逃生人数。
输出最终能够逃生的总人数，即剩余栈中的正数和累积存活的负数之和。

原文链接：https://blog.csdn.net/guorui_java/article/details/132112650
 */

// 思路：关键点--负数遇到正数要一直打架，一直打到没有正数了或者负数赢了为止。
const rl = require("readline").createInterface({
    input : process.stdin
})
var iter = rl[Symbol.asyncIterator]();
const readline = async ()=>(await iter.next()).value;
void (async ()=>{
    const list = (await readline()).split(" ").map(Number);
    console.log(getRes(list));
})();

const getRes = (list)=>{
    console.log(list);
    // 正数的栈
    let stack = [];
    // 负数的逃脱人数
    let ans = 0;
    for(let v of list){
        if(v>0){
            stack.push(v);
        }else{
            let power = -v;
        //     要和正数一直打架
            while(stack.length){
                let top = stack.pop();
                // 如果正数赢了，剩下差值入栈，跳出循环
                if(top > power){
                    stack.push(top-power);
                    // 负数被消耗了
                    power = 0;
                    break;
                }else if(top===power) {
                    // 同归于尽了
                    power = 0;
                    break;
                }else{
                    // 如果负数赢了，继续战斗
                    power -=top;
                }
            }
        //     全部战斗完成，如果负数还有能量，则可以逃脱了
            if(power>0){
                ans++;
            }
        }
    }
    return ans+stack.length;
}