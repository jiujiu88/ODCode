/*
题目描述
输入一串方波信号，求取最长的完全连续交替方波信号，并将其输出，如果有相同长度的交替方波信号，输出任一即可，
方波信号高位用1标识，低位用0标识，如图：

说明：
1） 一个完整的信号一定以0开始然后以0结尾，即010是一个完整信号，但101，1010，0101不是
2）输入的一串方波信号是由一个或多个完整信号组成
3） 两个相邻信号之间可能有0个或多个低位，如0110010，011000010
4） 同一个信号中可以有连续的高位，如01110101011110001010，前14位是一个具有连续高位的信号  --01110101011110是一个信号 中间一个低位0 01010是一个信号
5） 完全连续交替方波是指10交替，如01010是完全连续交替方波，0110不是

输入描述:
输入信号字符串（长度>=3且<=1024）：
0010101010110000101000010
注：输入总是合法的，不用考虑异常情况

输出描述:
输出最长的完全连续交替方波信号串：01010
若不存在完全连续交替方波信号串，输出 -1

示例1
输入
00101010101100001010010
输出
01010
备注:
输入信号串中有三个信号：
0 010101010110(第一个信号段)
00 01010(第二个信号段)
010(第三个信号段)
第一个信号虽然有交替的方波信号段，但出现了11部分的连续高位，不算完全连续交替方波，
在剩下的连续方波信号串中01010最长

原文链接：https://blog.csdn.net/lbp0123456/article/details/143674719
 */

const rl = require("readline").createInterface({
    input : process.stdin
})
var iter = rl[Symbol.asyncIterator]();
const readline = async ()=>(await iter.next()).value;
void (async ()=>{
    const s = await readline();
    console.log(getRes1(s));
})();

// 10101010100001010010
// 思路：一共有3种情况  00 01/10 11  由于信息开头结尾都必须为0，因此两个信号连接至少2个0
const getRes = (s)=>{
    let list = s.split("00").filter(v=>v);
    let res = "";
    console.log(list)
    for(let v of list){
    //     如果包含11，肯定不是方波信号
        if(v.includes("11")){
            continue;
        }
        // 前后补0 补完之后一定是方波信号
        if(v[v.length-1]!="0"){
            v += "0";
        }
        if(v[0]!="0"){
            v = "0"+v;
        }
        // 只要最长的
        if(v.length>res.length){
            res = v;
        }
    }
    return res==="" ? -1 : res;
}

//思路2：用正则获取，信号开头的地方一定是0，结尾的地方也是0，找到结尾00的地方表示是结束（第二个0是中间的连接低位或是第二个信号的开始0）
const getRes1 = (s)=>{
    // 结尾加0，否则最后一个正常信号无法识别
    s +="0";
    let res = "";
    let l = 0,r = 1;
    const reg = /^(01)+0$/;
    while(l<r && r<s.length){
        // 不考虑异常情况，因为s第一个字母一定是0 寻找开头为0，结尾为0的信号段
        if(s[r-1]==0 && s[r]==0){
            const subS = s.slice(l,r);
            // 直接找最长的
            if(reg.test(subS) && subS.length > res.length){
                res = subS;
            }
            console.log(l,r,subS);
            // 找下一个信号
            l = r;
        }
        r++;
    }
    return res==="" ? -1 : res;
}