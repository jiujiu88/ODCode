/*
题目描述
给出数字个数 n （0 < n ≤ 999）和行数 m（0 < m ≤ 999），从左上角的 1 开始，按照顺时针螺旋向内写方式，依次写出2,3,....,n，最终形成一个 m 行矩阵。
小明对这个矩阵有些要求：
1、每行数字的个数一样多
2、列的数量尽可能少
3、填充数字时优先填充外部
4、数字不够时，使用单个 * 号占位

输入描述
两个整数，空格隔开，依次表示 n、m

输出描述
符合要求的唯一矩阵

输入
9 4
输出
1 2 3
* * 4
9 * 5
8 7 6

输入
3 5
输出
1
2
3
*
*

输入
120 7
输出
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 19
45 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 63 20
44 83 114 115 116 117 118 119 120 * * * * * * 99 64 21
43 82 113 112 111 110 109 108 107 106 105 104 103 102 101 100 65 22
42 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 23
41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24
 */

const rl = require("readline").createInterface({
    input :process.stdin
})
// 思路：
rl.on("line",line=>{
    let [n,m] = line.split(" ").map(Number);
    // 创建二维数组 m行 n/m列
    let k = Math.ceil(n/m);
    let arr = new Array(m).fill("*").map(()=>new Array(k).fill("*"));
//     四个方向写数字
    let row=0,col=0;
    let i = 1;
    // 未填充过的，才填数字 每个循环都要限制i
    while(i<=n) {
        // 横向 左向右填充
        while (col < k && arr[row][col] == "*" && i<=n) {
            arr[row][col] = i++;
            col++;
        }
        // 恢复列
        col--;
        // 向下一行
        row++;
        // 纵向 上向下填充
        while (row < m && arr[row][col] == "*" && i<=n) {
            arr[row][col] = i++;
            row++;
        }
//     恢复行
        row--;
//     向左一列
        col--;
//     横向 右向左填充
        while (col >= 0 && arr[row][col] == "*" && i<=n) {
            arr[row][col] = i++;
            col--;
        }
        col++;
        row--;
        //     纵向 下向上填充
        while (row >= 0 && arr[row][col] == "*" && i<=n) {
            arr[row][col] = i++;
            row--;
        }
        row++;
        col++;
    }
    for(let i=0;i<m;i++){
        console.log(arr[i].join(" "))
    }
})