## 2、双指针 [题单](https://leetcode.cn/circle/discuss/0viNMK/)
### 1>单序列双指针
> 1.相向双指针(两个指针left=0, right=n−1，从数组的两端开始，向中间移动)
>```
> let left=0,right = n-1;
> while(left<right){
>     ...
> }

> 2.同向双指针

> 3.背向双指针

> 4.原地修改<br/>
> 一个有序数组nums，原地删除重复出现的元素，一个元素出现次数最多保留k次，返回删除后数组的新长度。例题：80
>```
>let n = nums.length;
>if (n <= k) return n;
>// 先保留前k位
>let slow = k;
>for (int i = k; i < n; i++)
>// 与当前写入的位置前面的第 k 个元素进行比较，不相同则保留
>if (nums[slow - k] != nums[i]){
>    // 如果是返回数组，可改为[nums[slow],nums[i]] = [nums[i],nums[slow]];
>    nums[slow++] = nums[i];
>}
>return slow;

### 2>双序列双指针
>1>双指针

>2>判断子序列（原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串）
>``` 
>// 2486 判断需要向s末尾追加多少字符使t是s的子序列
>let m = s.length
>let n = t.length
>let j = 0;
>for (let i = 0; i < m; i++) {
>    if (s[i] === t[j]) {
>        j++;
>    }
>}
>return n - j;
### 3>三指针（恰好型滑窗）
> 例如795 找在[left, right] 内的子数组个数，可以拆分为<=right的子数组个数-<=left-1的子数组个数
### 4>分组循环
> * 适用场景：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。
> * 核心思想：
外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。
内层循环负责遍历组，找出这一组最远在哪结束。
>``` 
>// 2760 分组循环模板
>let i = 0,res = 0,n = nums.length;
>while(i<n){
>    // 不符合要求，直接跳过
>    if(nums[i]>threshold || nums[i]%2!=0){
>        i++;
>        continue;
>    }
>    // 分组后，向右循环，获取结果
>    let start = i;
>    i++;
>    while(i<n && ...){
>        i++;
>    }
>    #从start到i-1是一组，下一组从i开始
>    res = Math.max(i-start,res);
>}
>return res;