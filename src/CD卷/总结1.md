1、正则：  替换前缀/后缀的所有/
prefix = prefix.replace(/\/+$/, "");
suffix = suffix.replace(/^\/+/, "");
字符串是否匹配指定的正则表达式，返回布尔值 reg.test(str)
获取匹配的结果,返回数组，不匹配返回null reg.exec(str)
返回字符串中与正则表达式匹配的结果,返回数组 str.match(reg)

2、递归技巧：
当需要回溯时，符合条件后一定要return，否则容易死循环.
数层去重(一定要排序！) if(i>0 && nums[i]==nums[i-1] && !used[i]) continue;
abc 需要获取到的结果是有序的，例abc、bac算两个不同的结果，则用used判断，排列
abc 需要获取到的结果是无序的，例abc、bac算一种结果，用lastIndex判断，组合
组合递归时，如果下一层可以重复使用，则startIndex传i，如果下一层不能重复使用，则传i+1
n个数的全排列数量有n!个，n个数的全组合数量有2^n-1个

3、栈问题技巧：
①拼接数组一起遍历 产生 循环数组效果
②使用下标代替值，速度更快  取模
③下一个更大/下一个更小/区间最值/滑窗 -> 单调栈
找更大，从左到右遍历每个元素：
栈中记录还没算出「下一个更大元素」的那些数的下标。
只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后弹出栈顶。
--
️查找 「比当前元素大的元素」 就用 单调递增栈（从栈顶到栈底而言），查找 「比当前元素小的元素」 就用 单调递减栈（从栈顶到栈底而言）。
从 「左侧」 查找就看 「插入栈」 时的栈顶元素，从 「右侧」 查找就看 「弹出栈」 时即将插入的元素。

模板：
3、岛屿问题模板:
const getRes = (m,n,k)=>{
    // 将地图可进的地方设置为1，不可进的地方设置为0。相当于从(0,0)走到所有1的地方
    let grid = Array.from({length:m},()=>Array(n).fill(0));
    const directs = [[-1,0],[1,0],[0,-1],[0,1]];
    const isInArea = (i,j)=>{
        return i>=0 && j>=0 && i<m && j<n;
    }
    let res = 0;
    const dfs = (i,j)=>{
    // 越界，返回
    if(!isInArea(i,j)){
        return;
    }
    // 不可访问、已遍历过都返回
    if(cache[i][j]>k || grid[i][j]===1){
        return;
    }
    // 如果遍历到了，设置为1
    grid[i][j]=1;
    // 遍历4个方向
    for(let v of directs){
        let newI = i + v[0],newJ = j+v[1];
        dfs(newI,newJ);
    }
}

4、滑动窗口模板:
定长-入更新出  if(i+1<k) continue; 出的元素arr[i+1-k]
非定长- 最长/最短子数组、子数组个数  
for(let i=0;i<s.length;i++){
    map.set(s[i],(map.get(s[i])||0)+1);
    // 判断条件，缩小窗口
    while(map.get(s[i])>2){
        map.set(s[left],(map.get(s[left])||0)-1);
        left++;
    }
    // 记录结果
    res = Math.max(res,i-left+1);
}
分组滑窗
例2831 分组思路 
将相同元素下标作为数组，分组。循环每个分组进行滑窗，删除的个数为v[right]-v[left]-(right-left)

5、01背包问题-DP模板

6、完全背包问题模板

7、并查集模板
class UnionFindSet{
    constructor(n){
        this.fa = Array(n).fill(0).map((_,idx)=>idx);
        // 初始化为n个
        this.count = n;
    }
    find(x){
        // 不为自己时才递归查找
        if(x!=this.fa[x]){
            return this.fa[x] = this.find(this.fa[x]);
        }else{
            return x;
        }
    }
    union(x,y){
        let fa_x = this.find(x);
        let fa_y = this.find(y);
        // 不在一个连通分量时，需要连接，连接后连通分量-1
        if(fa_x!=fa_y) {
            this.fa[fa_x] = fa_y;
            this.count--;
        }
    }
}
// 使用
const ufs = new UnionFindSet(m*n);
非结果，count--
ufs.count--;
找到连通分量， 合并
ufs.union(i*m+j,newI*m+newJ);

技巧：
1、IP串转为数字
const trans2Num = (ip)=>{
    //     例如1.1.1.1 ，转为整数
    let list = ip.split(".");
    let res = "";
    for(let v of list){
        res = parseInt(v) | (res<<8);
    }
    return res;
}

2、计算位数和
// 计算数位之和 例如 grid[10][21] 横坐标数位为1+0=1，纵坐标为2+1=3，和为4
const getSum = (idx)=>{
    let sum = 0;
    while(idx!==0){
        let digit = idx%10;
        sum +=digit;
        idx = Math.floor(idx/10);
    }
    return sum;
}

3、辗转相除法，求两个数的最大公约数
function getMaxCommonDivisor(x, y) {
    while (y != 0) {
        let tmp = y;
        y = x % y;
        x = tmp;
    }
    return x;
}

4、差分数组  
let max = 0;
for(let [s,e] of arr){
    max = Math.max(max,e);
}
const diff = Array(max+2).fill(0);
for(let [s,e,cnt] of arr){
    diff[s] += cnt;
    diff[e+1] -= cnt;
}
let cur = 0,res = 0;
for(let v of diff){
    cur +=v;
    res = Math.max(res,cur);
}



