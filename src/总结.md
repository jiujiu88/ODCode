# 哈希 
#### 快速判断一个元素是否出现集合里
* 数组
```
// 快速计算字母的个数  大小写、数字、字母、空格可用128个
let map = new Array(26).fill(0);
let base = 'a'.charCodeAt();
let b = s[right].charCodeAt()-base;
map[b]++;
```
> 
> 1、只有0、1的数组，cnt0记录0的个数，可以用1-nums[i]  cnt0 += 1-nums[i] <br/>
0、1可以表示为 x.charCodeAt()%2 或者 x-0 或者 x&1（奇数&1为1等于奇数%2==1）

* set(集合)
> 一般判断是否存在重复字串，即个数为1时直接用set
> 快速判断字符串中是否是一些字母中的其中一个，可以用set  new Set("aeiou")判断是元音字符
* map(映射)
> 一般用于判断不同字符的个数(大于1)，用map<br/>
> 获取map值的数组Array.from(map.values())<br/>
> 取map的值中最大的值 Math.max(...(Array.from(map.values())))<br/>
> 当记录数组中多个数的差值时用max-min，如果直接用Math.max(...nums.slice(l,r))超时，可以借助map计算Math.max(...map.keys())

# 队列 
* 当记录变化数组中最大最小值时，可以通过双端队列维护最大值和最小值（例1438）
```
维护最大最小值 max为单调递减队列，头部为最大值;min为单调递增队列，头部是最小值
while(max.length>0 && nums[r]>max[max.length-1]){
    max.pop();
}
max.push(nums[r]);
// l指针需移出队列
if(max[0]==nums[l]){
    max.shift();
}
```

# 数组
技巧
```
1、计算排序字符串中最小字符的个数 str.lastIndexOf(str[0])+1
2、统计子数组中某个元素的个数，可以考虑用分组，将每个元素的下标记录下来
```
## 1、二分法
### 1>二分查找
使用场景<br/>
> 1.在有序数组中快速查找一个元素target的位置<br/>
> 2.在有序数组中，一个数出现的次数大于n/2,那么这个数就是众数 nums[n/2]一定是target，找出现次数就可以用二分查找第一个位置和最后一个位置
#### $$红蓝染色法~~ ~~循环不变量~~ ~~L-1始终是红色~~ ~~R+1始终是蓝色$$
>* 需要找元素的第一个位置 <x表示红色（不满足要求），>(=)x表示蓝色（满足要求）<br/> 
>* 转换=》 >x变为>=x+1  <x变为nums(>=x)-1  <=x变为nums(>=x+1)-1

>+ 左闭右闭[left,right] 初始化l=0,r=n-1 条件l<=r 循环l=mid+1,r=mid-1 结果left=right+1是第一个>(=)x的下标<br/>
>+ 左闭右开[left,right) 初始化l=0,r=n 条件l<r 循环l=mid+1,r=mid 结果left=right是第一个>(=)x的下标<br/>
>+ 左开右开(left,right) 初始化l=-1,r=n 条件l+1<r 循环l=mid,r=mid 结果right=left+1是第一个>(=)x的下标<br/>
#### 左闭右闭
    let left = 0,right = nums.length-1;
    while(left<=right)
    // mid即right+1一定指向蓝色即>=target
    mid >=target right = mid-1
    // mid即left-1一定指向红色即<target
    mid <target left = mid+1
    // 循环不变量，right指向最后一个红色，left指向最先一个蓝色，right+1=left指向第一个蓝色(>=target)的结果
    return left/right+1
#### 左闭右开
    let left = 0,right = nums.length-1;
    while(left<right)
    mid >=target right = mid
    mid <target left = mid+1
    return left/right
#### 左开右开
    let left = -1,right = nums.length-1;
    while(left+1<right)
    mid >=target right = mid
    mid <target left = mid
    return right/left+1

### 2>二分答案：求最小或最大值
例如：开区间
* 求最小：check(mid) == true 时更新 right = mid，反之更新 left = mid，最后返回 right。
* 求最大：check(mid) == true 时更新 left = mid，反之更新 right = mid，最后返回 left。
```
示例：左开右开
function check(target){
    let sum = 0;
    for(let v of nums){
        sum += Math.ceil(v/target);
    }
    return sum<=threshold;
}
let left = 0,right = Math.max(...nums);
while(left+1<right){
    let mid = Math.floor((left+right)/2);
    if(check(mid)){
        // 如果符合条件，再找更小的
        right = mid;
    }else{
        left = mid;
    }
}
return right;

```
## 2、双指针 [题单](https://leetcode.cn/circle/discuss/0viNMK/)
### 1>单序列双指针
> 1.相向双指针(两个指针left=0, right=n−1，从数组的两端开始，向中间移动)
>```
> let left=0,right = n-1;
> while(left<right){
>     ...
> }

> 2.同向双指针

> 3.背向双指针

> 4.原地修改<br/>
> 一个有序数组nums，原地删除重复出现的元素，一个元素出现次数最多保留k次，返回删除后数组的新长度。例题：80
>```
>let n = nums.length;
>if (n <= k) return n;
>// 先保留前k位
>let slow = k;
>for (int i = k; i < n; i++)
>// 与当前写入的位置前面的第 k 个元素进行比较，不相同则保留
>if (nums[slow - k] != nums[i]){
>    // 如果是返回数组，可改为[nums[slow],nums[i]] = [nums[i],nums[slow]];
>    nums[slow++] = nums[i];
>}
>return slow;

### 2>双序列双指针
>1>双指针

>2>判断子序列（原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串）
>``` 
>// 2486 判断需要向s末尾追加多少字符使t是s的子序列
>let m = s.length
>let n = t.length
>let j = 0;
>for (let i = 0; i < m; i++) {
>    if (s[i] === t[j]) {
>        j++;
>    }
>}
>return n - j;
### 3>三指针（恰好型滑窗）
> 例如795 找在[left, right] 内的子数组个数，可以拆分为<=right的子数组个数-<=left-1的子数组个数
### 4>分组循环
> * 适用场景：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。
> * 核心思想：
外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。
内层循环负责遍历组，找出这一组最远在哪结束。
>``` 
>// 2760 分组循环模板
>let i = 0,res = 0,n = nums.length;
>while(i<n){
>    // 不符合要求，直接跳过
>    if(nums[i]>threshold || nums[i]%2!=0){
>        i++;
>        continue;
>    }
>    // 分组后，向右循环，获取结果
>    let start = i;
>    i++;
>    while(i<n && ...){
>        i++;
>    }
>    #从start到i-1是一组，下一组从i开始
>    res = Math.max(i-start,res);
>}
>return res;
## 3、滑动窗口 [题单](https://leetcode.cn/circle/discuss/0viNMK/)
* 必须有单调性（恒定非正或非负）才可以用滑动窗口,是一种特殊的同向双指针
* 当计算和时，如果窗口缩小后left和right指针的值会相等（非完全递增），需加上限制条件left<=right
### 1>定长滑动窗口：入-更新-出<br/>
入：下标为 i 的元素进入窗口，更新相关统计量。如果 i<k−1 则重复第一步。<br/>
更新：更新答案。一般是更新最大值/最小值。 <br/>
出：下标为 i−k+1 的元素离开窗口，更新相关统计量。<br/>
```
1.如果需要计算和，数组中有负数或逻辑复杂，可以先计算前k个总和
let sum= nums.slice(0,k).reduce((a,b)=>a+b);
let res = sum;
for(let i=k;i<nums.length;i++){
    ...
}
2.通用公式
for(let i=0;i<arr.length;i++){
    // 入
    sum+=arr[i];
    if(i+1<k) continue;
    // 记录结果  判断界定条件
    if(sum>=target){
        res++;
    }
    // 出
    sum -=arr[i-k+1];
}
```
```
技巧：
1、1461 获取长度为k的子字符串 s.slice(i,i+k) 或 滑窗:入str +=s[i] 出 str=str.slice(1) 
2、1423 先获取前k个的和，从1循环到k，再加右侧n-i,减左侧（右边）k-i。
3、1652 方法一 复制两个不怕越界 计算res[0]的和，再循环获取所有的数  方法二 用余数
4、经典 1297
```
> 1.判断两个字母的字符个数都一样--字母异位词分组

    1>排序 [...str].sort().toSting()  排序后字符串相等（a,b,c），可以作为哈希表的键
    2>计数 count[c.charCodeAt()-'a'.charCodeAt()]++  count可以作为map={}的键
> 2.判断两个字母的个数是否不一样

    先计算出字母A的所有个数count 计算B时循环字符x count[x]-- 如果count[x]<0则表示两个字母不是异位词
> 3.重复两个数组，取首尾连续子数组防止越界 数组值用nums[i%n] (例题：1652、2875)
```
// 循环两个相同数组，求连续子数组的和，可以避免首尾问题
for(let i=0;i<2*n;i++){
    // 用余数获取当前下标
    count +=nums[i%n];
    while(count>target%sum){
        count -=nums[left++%n];
    }
}
```
### 2>不定长滑动窗口
#### 主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。
> **1、求最长/最大   一般题目都有「至多」的要求**
```
let map = new Map();
let left = 0;
let res = 0;
for(let i=0;i<s.length;i++){
    map.set(s[i],(map.get(s[i])||0)+1);
    // 判断条件，缩小窗口
    while(map.get(s[i])>2){
        map.set(s[left],(map.get(s[left])||0)-1);
        left++;
    }
    // 记录结果
    res = Math.max(res,i-left+1);
}
return res;
```
```
技巧：
1、判断重复字符用set 先判断set.has(nums[i]) 再加set.add(nums[i])
2、只有0、1的数组，cnt0记录0的个数，可以用1-nums[i]  cnt0 += 1-nums[i]
3、2779 nums[i]可替换为[nums[i] - k, nums[i] + k] 画图用区间表示，排序后求x+k和y-k有交集即y-x<=2k时最大的x和y的长度
4、2024 只有T、F的数组，最多替换k次得到最长连续数组 判断条件为T、F的个数都超过k时缩小窗口
5、1838 排序数组 right增加，left到right下标的差值累加，sum +=nums([right]-nums[right-1])*(right-left);
6、2831 分组思路 将相同元素下标作为数组，分组。循环每个分组进行滑窗，删除的个数为v[right]-v[left]-(right-left)
```
#### 正难则反（将取首尾的数据转化为取中间连续的数）
    1658 逆向思维 求和为x的最小个数（可首尾拿取），转化为求和为s-x的最长子数组的长度（必连续）
    2516 每种字符至少取k个，转化为剩下字母至多有sum-k个 计算s的最长子串长度，该子串满足a,b,c的个数分别至多为 x−k,y−k,z−k
> **2、求最短/最小   一般题目都有「至少」的要求**
```
let res = Infinity;
let sum = 0;
let left = 0;
for(let i=0;i<nums.length;i++){
    sum +=nums[i];
    // 和大于等于target时，结果满足，记录结果，由于是正整数，右移肯定满足，因此需缩小窗口找到更小的
    while(sum>=target){
        res = Math.min(res,i-left+1);
        sum -=nums[left];
        left++;
    }
}
// 如果没有满足条件的，则返回0
return res==Infinity?0:res;
```
```
技巧：
2904 while条件：个数超过k或者左侧字段为0，都要缩小窗口 while后记录结果
1234 在删除后所有字符的个数都小于target，此时可以替换为平衡字符串，左指针右滑获取最小结果。
```
> **3、求子数组个数**
>>1.越长越合法 一般要写 ans += left
>>>滑动窗口的内层循环结束时，右端点固定在right,左端点在0,1,2,…,left−1的所有子数组（子串）都是合法的，这一共有left个。
```
let ans = 0, left = 0;
const cnt = [0, 0, 0];
for (let right = 0; right < s.length; right++) {
    cnt[s.charCodeAt(right) - 'a'.charCodeAt(0)]++;
    while (cnt[0] > 0 && cnt[1] > 0 && cnt[2] > 0) {
        cnt[s.charCodeAt(left) - 'a'.charCodeAt(0)]--;
        left++;
    }
    ans += left;
}
return ans;
```
>>2.越短越合法 一般要写 ans += right - left + 1
>>>滑动窗口的内层循环结束时，右端点固定在right,左端点在left,left+1,…,right的所有子数组（子串）都是合法的，这一共有right−left+1 个。<br/>

>>3.恰好型滑动窗口
>>>「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。或两个至多，越短越合法
```
例1248
var numberOfSubarrays = function(nums, k) {
    // 大于等于k个奇数 减去 大于等于k+1个奇数 等于恰好为k个奇数的个数
    return getRes(nums,k)-getRes(nums,k+1);
};

// 获取大于等于k个奇数的个数
function getRes(nums,k){
    let res = 0;
    let left = 0;
    // 记录奇数的个数
    let sum = 0;
    for(let i=0;i<nums.length;i++){
        sum +=nums[i]%2;
        while(sum>=k){
            sum -=nums[left++]%2;
        }
        // i=3 left=1 1121 i=4 left=2 11211 1211
        res +=left;
    }
    return res;
}
```
>>> 三指针滑动窗口：也可以把两个滑动窗口合并起来，维护同一个右端点right和两个左端点left1和left2
```
例930 nums = [1,0,1,0,1], goal = 2
// 三指针滑动窗口  用至少和为goal的子数组个数减去至少和为goal+1的子数组个数 两个越长越合法
let l1 = l2 = sum1 = sum2 = 0;
let res = 0;
for(let r=0;r<nums.length;r++){
    sum1 +=nums[r];
    sum2 +=nums[r];
    // 计算至少和为goal的子数组个数
    while(l1<=r && sum1>=goal){
        sum1 -=nums[l1++];
    }
    // 计算至少和为goal的子数组个数
    while(l2<=r && sum2>=goal+1){
        sum2 -=nums[l2++];
    }
    // r=2 l1=1 sum1=1 101 +1  
    // r=3 l1=1 l2=0 1010 +1
    // r=4 l1=3 sum1=1 10101 0101 101 +3 l2=1 sum2=2 10101 +1 实际满足0101 101 l1-l2=2
    res +=l1-l2;
}
return res;
```
## 4、模拟行为
    螺旋数组 上下左右四个参数 模拟转圈
    每次转圈时判定边界  if(--b<t) break;
## 5、前缀和 
```
sumArr = new Array(n+1)
sumArr[0] = 0
i=1 i<=n  sumArr[i] = sumArr[i-1]+arr[i-1]
计算left到right中的和:sumArr[right+1]-sumArr[left]
```
* 例930

