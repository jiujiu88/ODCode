/*
题目描述
在做物理实验时，为了计算物体移动的速率，通过相机等工具周期性的采样物体移动距离。
由于工具故障，采样数据存在误差甚至错误的情况。
需要通过一个算法过滤掉不正确的采样值。
不同工具的故障模式存在差异，算法的各类门限会根据工具类型做相应的调整。
请实现一个算法，计算出给定一组采样值中正常值的最长连续周期。

判断第 i 个周期的采样数据 S[i] 是否正确的规则如下（假定物体移动速率不超过10个单元，前一个采样周期 S[i-1] )：
S[i] <= 0，即为错误值
S[i] < S[i-1]，即为错误值
S[i] - S[i-1] >= 10，即为错误值
其它情况为正常值
判断工具是否故障的规则如下：
在M个周期内，采样数据为错误值的次数为T（次数可以不连续），则工具故障。
判断故障恢复的条件如下：
产生故障后的P个周期内，采样数据一直为正常值，则故障恢复。
错误采样数据的处理方式：
检测到故障后，丢弃从故障开始到故障恢复的采样数据。
在检测到工具故障之前，错误的采样数据，则由最近一个正常值代替；如果前面没有正常的采样值，则丢弃此采样数据。
给定一段周期的采样数据列表S，计算正常值的最长连续周期。

输入描述
故障确认周期数和故障次数门限分别为M和T，故障恢复周期数为P。
第 i 个周期，检测点的状态为Si
输入为两行，格式如下：
M T P
S1 S2 S3 ...
M、T和P的取值范围为[1, 100000]
Si取值范围为[0, 100000]，i 从0开始编号

输出描述
一行输出正常值的最长连续周期

用例
输入	10 6 3
-1 1 2 3 100 10 13 9 10
输出	8
说明	S[0]，S[4]，S[7]，S[8]为错误值。S[0]之前没有正常的采样数据，丢弃S[0]。S[4]和S[7]不满足故障条件，此值分别由S[3]和S[6]代替，即S[4]为3，S[7]为13。替换后，S[8]小于S[7]，也是错误值。
输入	5 3 3
0 1 2 -1 4 3 6 7 6 6 10 11 12
输出	9
说明	S[3]，S[5]，S[8]，S[9]为错误值。从S[3]到S[7]的5个周期内只有两个错误值S[3]和S[5]。从S[5]到S[9]的5个周期内有三个错误值S[5]、S[8]和S[9]，工具故障。丢弃S[9]到S[12]的值。
输入	5 3 3
1 2 -1 -2 -3 6 7 8 9 10 11 12
输出	5
说明	S[2]，S[3]，S[4]为错误值。从S[2]到S[6]的5个周期内有三个错误值，工具故障。丢弃S[4]到S[6]的值。有两段正常连续周期，S[0]到S[3]（周期数为4）和S[7]到S[11]（周期数为5）。
 */

const rl = require("readline").createInterface({
    input:process.stdin
})
// 思路：找到故障前，找到故障后
const iter = rl[Symbol.asyncIterator]();
const readline = async ()=>(await iter.next()).value;
void (async function (){
    const [m,t,p] = (await readline()).split(" ").map(Number);
    const s = (await readline()).split(" ").map(Number);
    console.log(getRes(m,t,p,s));
})()

const getRes = (m,t,p,s)=>{
//     先将数组变为正常数组
    let arr1 = [];
    // 在检测到工具故障之前errSum<t时，错误的采样数据，则由最近一个正常值代替；如果前面没有正常的采样值，则丢弃此采样数据。
    // 设置前面的正常值
    let preVal = null;
    for (let i=0;i<s.length;i++){
        // 判断是正确值还是错误值
        if((i>0 && (s[i]<s[i-1] || s[i]-s[i-1]>=10)) || s[i]<=0){
            if(preVal!=null){
                // 赋值为上一个正常值
                s[i] = preVal;
                arr1.push(0);
            }
            // 如果前面没有正常的采样值，则丢弃此采样数据
        }else{
            // 正常值，更新preVal的值以便遇到错误值可以用到，arr1数组记录正常值
            preVal = s[i];
            arr1.push(1);
        }
    }
    return arr1;
    // // 检测到故障后，丢弃从故障开始到故障恢复的采样数据
    //         if(errSum>=t){
    //             // 恢复初始值，重新记录
    //             errSum = 0;
    //             // 计算连续正常的采样数据，如果连续p次正常，则故障恢复
    //
    //         }
//     输入	10 6 3
//     -1 1 2 3 100 10 13 9 10
//     输出	8
//     说明	S[0]，S[4]，S[7]，S[8]为错误值。S[0]之前没有正常的采样数据，丢弃S[0]。S[4]和S[7]不满足故障条件，此值分别由S[3]和S[6]代替，即S[4]为3，S[7]为13。替换后，S[8]小于S[7]，也是错误值。
// 输入	5 3 3
//     0 1 2 -1 4 3 6 7 6 6 10 11 12
//       1 2 2 4 4 6 7 7 7 10 11 12
//     输出	9
//     说明	S[3]，S[5]，S[8]，S[9]为错误值。从S[3]到S[7]的5个周期内只有两个错误值S[3]和S[5]。从S[5]到S[9]的5个周期内有三个错误值S[5]、S[8]和S[9]，工具故障。丢弃S[9]到S[12]的值。
// 输入	5 3 3
//     1 2 -1 -2 -3 6 7 8 9 10 11 12
//     输出	5
}

