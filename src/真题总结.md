###
1、匹配带可选段的字符串(a[bc]de[xcv] 转化为[Set(1) { 'a' },Set(2) { 'b', 'c' },Set(1) { 'd' },Set(1) { 'e' },Set(3) { 'x', 'c', 'v' }])
```
const level = [];
const isOpen = false;
const set = new Set();
for (const c of s) {
    if (c == '[') {
        isOpen = true;
    }   
    else if (c == ']') {
        isOpen = false;
        level.push(set);
        set = new Set();     
    }else{
        if(isOpen){
            set.add(c);
        }else{
            level.push(new Set(c));
        }
    }
}
用level[i].has(x)判断是否匹配
```

2、计算连续子序列、数组，如果结果可能为0或left=right,需要加条件left<right

3、判断一个字符为某些字符串x则符合条件时，可用set设置字符串x,用set.has(c)判断是否符合条件  例判断元音字母、数字等

4、指定字符串中有x个不同的元素，求此时最长符合条件（包含a个不同元素）子串的长度：先分组得到相同数据下标数组，然后循环通过arr[right]-arr[left]-(right-left)
获取left~right下标的子串中不同元素的个数，符合条件时记录最长子串长度。
```例双指针11 最长的指定瑕疵度的元音子串
    let left = 0;
    for(let right=0;right<idxs.length;right++){
        let err = idxs[right]-idxs[left]-(right-left);
        // 如果瑕疵度大于指定值，缩小窗口减少瑕疵度
        while(err>flaw){
            left++;
            err = idxs[right]-idxs[left]-(right-left);
        }
        // 如果瑕疵度等于指定值，更新结果，记录子串的长度
        if(err===flaw){
            res = Math.max(res,idxs[right]-idxs[left]+1);
        }
    }
```

5、字符串（长度为n）中可以添加x个指定元素A，求添加后元素为A的连续子串的长度：
1>记录非元素A的下标数组idx
2>循环idx，下标为i，补种k个，计算连续子串的left和right索引
添加元素A后，数组长度为n+x+1,此时可以添加的元素A的连续子串的长度为n+x+1-(非元素A的下标数组长度+1)
①从前往后补：left为0，right为idx[i+k]-1
②从后往前补：left为idx[i-1]+1，right为n-1
③从中间补：left为idx[i-1]+1，right为idx[i+k]-1
```例双指针13 五子棋迷、滑窗2 补种未成活胡杨
    let left = i==0?0:idxs[i-1]+1;
    let right = i=idx.length-1?n-1:idxs[i+k]-1;
    let len = right-left+1;
```